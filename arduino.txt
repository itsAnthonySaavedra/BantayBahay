/*
  ESP32 BantayBahay Pairing Firmware (FINAL CODE-ONLY FIX)
  ‚ú® Bypass library limitations by manually exchanging tokens
  ‚ú® No library file editing required
  ‚ú® Compiles on default settings
*/

#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <WiFiClientSecure.h>

// Ensure you have "Firebase ESP32 Client" (Mobizt) and "ArduinoJson" (v6) installed
#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

#include <ArduinoJson.h>
#include <time.h>

// -------------------------------------------------------------------
// üî• FIREBASE CONFIG
// -------------------------------------------------------------------
#define API_KEY "AIzaSyCUD9ZbAWxGmbDJmmFnP-5kxNSn7uuAaSI"
#define DATABASE_URL "https://bantaybahay-be020-default-rtdb.asia-southeast1.firebasedatabase.app/"

// -------------------------------------------------------------------
// üîå SENSOR CONFIG
// -------------------------------------------------------------------
const int reedPin = 22;

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

bool firebaseReady = false;
String currentIdToken = "";

String savedDeviceId = "";
String savedCustomToken = "";
String savedSsid = "";
String savedPass = "";
String savedRefreshToken = "";

// -------------------------------------------------------------------
// üîß MANUAL TOKEN EXCHANGE (Bypasses library restriction)
// -------------------------------------------------------------------
String exchangeCustomToken(String customToken) {
  Serial.println("Token to exchange (" + String(customToken.length()) + " chars): " + customToken.substring(0, 20) + "..." + customToken.substring(customToken.length()-20));

  WiFiClientSecure client;
  client.setInsecure(); // Skip SSL certificate check

  const char* host = "identitytoolkit.googleapis.com";
  const int httpsPort = 443;

  if (!client.connect(host, httpsPort)) {
    Serial.println("Google API Connection Failed");
    return "";
  }

  String url = "/v1/accounts:signInWithCustomToken?key=" + String(API_KEY);
  
  // Create JSON Payload
  DynamicJsonDocument reqDoc(4096); // HEAP allocation
  reqDoc["token"] = customToken;
  reqDoc["returnSecureToken"] = true;
  String body;
  serializeJson(reqDoc, body);

  // Send POST Request
  client.println("POST " + url + " HTTP/1.1");
  client.println("Host: " + String(host));
  client.println("Content-Type: application/json");
  client.println("Content-Length: " + String(body.length()));
  client.println();
  client.print(body);

  // Wait for response
  unsigned long timeout = millis();
  while (client.connected() && !client.available()) {
    if (millis() - timeout > 5000) return "";
    delay(10);
  }

  // Skip headers
  bool jsonStarted = false;
  String jsonResponse = "";
  while (client.available()) {
    char c = client.read();
    if (c == '{') jsonStarted = true;
    if (jsonStarted) jsonResponse += c;
  }

  // Parse ID Token
  DynamicJsonDocument resDoc(4096); // HEAP allocation
  deserializeJson(resDoc, jsonResponse);
  
  const char* idToken = resDoc["idToken"];
  if (idToken) {
    const char* rToken = resDoc["refreshToken"];
    if (rToken) {
        Serial.println("Refresh Token Acquired from Custom Token!");
        savedRefreshToken = String(rToken);
    }
    return String(idToken);
  } else {
    Serial.println("Token Exchange Error: " + jsonResponse);
    return "";
  }
}

// -------------------------------------------------------------------
// üîß MANUAL REFRESH TOKEN EXCHANGE (Stability Fix with Retry)
// -------------------------------------------------------------------
String exchangeRefreshToken(String refreshToken) {
  Serial.println("Refreshing ID Token...");
  WiFiClientSecure client;
  client.setInsecure(); 
  
  const char* host = "securetoken.googleapis.com";
  
  for (int i = 0; i < 3; i++) {
      if (client.connect(host, 443)) break;
      Serial.println("Auth Host Connection Failed (" + String(i+1) + "/3)");
      delay(1000);
      if (i == 2) return "";
  }
  
  String url = "/v1/token?key=" + String(API_KEY);
  String payload = "grant_type=refresh_token&refresh_token=" + refreshToken;
  
  client.println("POST " + url + " HTTP/1.1");
  client.println("Host: " + String(host));
  client.println("Content-Type: application/x-www-form-urlencoded");
  client.println("Content-Length: " + String(payload.length()));
  client.println();
  client.print(payload);
  
  // Wait
  unsigned long timeout = millis();
  while (client.connected() && !client.available()) {
    if (millis() - timeout > 10000) return ""; // Increased timeout
    delay(10);
  }
  
  // Read
  String jsonResponse = "";
  bool start = false;
  while (client.available()) {
     char c = client.read();
     if (c == '{') start = true;
     if (start) jsonResponse += c;
  }
  
  DynamicJsonDocument doc(4096);
  deserializeJson(doc, jsonResponse);
  
  const char* newIdToken = doc["id_token"];
  if (newIdToken) {
      // Refresh token might rotate, preserve if returned
      const char* newRefresh = doc["refresh_token"];
      if (newRefresh) {
         savedRefreshToken = String(newRefresh); 
      }
      return String(newIdToken);
  } else {
      Serial.println("Refresh Failed: " + jsonResponse);
      return "";
  }
}

// -------------------------------------------------------------------
// üì° AP MODE CONFIG
// -------------------------------------------------------------------
WebServer server(80);
String apSSID;
const char* apPass = "pairme123";
const char* CONFIG_FILE = "/device_demo.json";

// -------------------------------------------------------------------
// üìÅ Save/Load Config
// -------------------------------------------------------------------
bool saveConfig(String id, String token, String ssid, String pass, String refresh) {
  DynamicJsonDocument doc(4096); // HEAP allocation
  doc["deviceId"] = id;
  doc["token"] = token;
  doc["refresh"] = refresh;
  doc["ssid"]  = ssid;
  doc["password"] = pass;

  File f = SPIFFS.open(CONFIG_FILE, FILE_WRITE);
  if (!f) return false;
  serializeJson(doc, f);
  f.close();
  return true;
}

// Overload for backward compatibility / easy calling
bool saveConfig(String id, String token, String ssid, String pass) {
    return saveConfig(id, token, ssid, pass, savedRefreshToken);
}

bool loadConfig() {
  if (!SPIFFS.exists(CONFIG_FILE)) return false;
  File f = SPIFFS.open(CONFIG_FILE, FILE_READ);
  DynamicJsonDocument doc(4096); // HEAP allocation
  if (deserializeJson(doc, f)) { f.close(); return false; }
  f.close();

  savedDeviceId = doc["deviceId"].as<String>();
  savedCustomToken = doc["token"].as<String>();
  if (doc.containsKey("refresh")) {
      savedRefreshToken = doc["refresh"].as<String>();
  }
  savedSsid = doc["ssid"].as<String>();
  savedPass = doc["password"].as<String>();
  return true;
}

// -------------------------------------------------------------------
// üåê Setup WiFi
// -------------------------------------------------------------------
bool connectToWiFi(String ssid, String pass) {
  Serial.println("Connecting to WiFi...");
  Serial.println("SSID: [" + ssid + "]");
  
  // OPTIMIZED: Removed aggressive disconnect/reset which wipes NVS
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid.c_str(), pass.c_str());

  int attempt = 0;
  // Increase timeout to 300 attempts (150 seconds)
  while (WiFi.status() != WL_CONNECTED && attempt < 300) { 
    delay(500); Serial.print("."); attempt++;
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
      delay(2000); // Allow stack to settle
      Serial.println("WiFi Connected!");
      Serial.println("IP: " + WiFi.localIP().toString());
      return true;
  } else {
      Serial.println("WiFi Connection FAILED (Timeout)");
      return false;
  }
}

// -------------------------------------------------------------------
// üî• Initialize Firebase (Using Manual Token)
// -------------------------------------------------------------------
bool initFirebase(String deviceId, String customToken) {
  // 1. Try Refresh Token First
  if (savedRefreshToken.length() > 20) {
      Serial.println("Using Saved Refresh Token");
      currentIdToken = exchangeRefreshToken(savedRefreshToken);
      
      if (currentIdToken != "") {
         config.api_key = API_KEY;
         config.database_url = DATABASE_URL;
         config.signer.tokens.legacy_token = currentIdToken.c_str(); // Use legacy_token for manual ID tokens
         
         Firebase.begin(&config, &auth);
         Firebase.reconnectWiFi(true);
         return true;
      } else {
         Serial.println("Refresh failed. Trying Custom Token fallback...");
      }
  }

  // 2. Fallback to Custom Token Exchange
  Serial.println("Exchanging Custom Token...");
  currentIdToken = exchangeCustomToken(customToken);

  if (currentIdToken == "") return false;

  // SAVE THE NEW REFRESH TOKEN PERMANENTLY
  if (savedRefreshToken.length() > 0) {
      saveConfig(savedDeviceId, savedCustomToken, savedSsid, savedPass, savedRefreshToken);
  }

  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  
  // FIX: Use legacy_token slot for manual ID token to avoid compilation errors
  config.signer.tokens.legacy_token = currentIdToken.c_str();

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  
  // Wait for readiness
  unsigned long start = millis();
  while (!Firebase.ready() && millis() - start < 5000) delay(100);

  if (Firebase.ready()) {
    Serial.println("Firebase Ready!");
    return true;
  }
  return false;
}

// -------------------------------------------------------------------
// üõú AP Endpoints
// -------------------------------------------------------------------
void handlePair() {
  Serial.println("Received pairing request!"); 
  
  if (server.method() != HTTP_POST) {
    server.send(405, "application/json", "{\"status\":\"bad_method\"}");
    return;
  }
  String body = server.arg("plain");
  Serial.println("Body: " + body);

  DynamicJsonDocument doc(4096); 
  if (deserializeJson(doc, body)) {
    server.send(400, "application/json", "{\"status\":\"bad_json\"}");
    return;
  }

  String id = doc["deviceId"];
  String tilde = doc["token"];
  String s = doc["ssid"];
  String p = doc["password"];

  if (saveConfig(id, tilde, s, p)) {
    server.send(200, "application/json", "{\"status\":\"ok\"}");
    delay(500);
    ESP.restart();
  } else {
    server.send(500, "application/json", "{\"status\":\"save_fail\"}");
  }
}

void startAP() {
  uint64_t chipid = ESP.getEfuseMac();
  apSSID = "ESP32-" + String((uint32_t)chipid, HEX);
  WiFi.mode(WIFI_AP);
  WiFi.softAP(apSSID.c_str(), apPass);
  Serial.println("AP: " + apSSID);
  Serial.println(WiFi.softAPIP());
  server.on("/pair", HTTP_POST, handlePair);
  server.begin();
}

// -------------------------------------------------------------------
// üïí Time
// -------------------------------------------------------------------
void initTime() { configTime(28800, 0, "pool.ntp.org"); }
String getTimeString() {
  time_t now = time(nullptr);
  struct tm *timeinfo = localtime(&now);
  if (timeinfo->tm_year < 120) return "Time not set";
  char buffer[25];
  strftime(buffer, 25, "%Y-%m-%d_%H-%M-%S", timeinfo);
  return String(buffer);
}

// -------------------------------------------------------------------
// üî• Send Logic
// -------------------------------------------------------------------
void sendState(String state) {
  // Re-auth if needed
  if (!Firebase.ready()) {
     initFirebase(savedDeviceId, savedCustomToken);
  }

  String ts = getTimeString();
  if (ts == "Time not set") return;

  Firebase.RTDB.setString(&fbdo, "/devices/" + savedDeviceId + "/door_status", state);
  Firebase.RTDB.setString(&fbdo, "/devices/" + savedDeviceId + "/logs/" + ts, state);
  Firebase.RTDB.setString(&fbdo, "/events/" + savedDeviceId + "/" + ts, state);
  Serial.println("Sent: " + state);
}

// -------------------------------------------------------------------
// ‚è∞ Auto-Arm Logic
// -------------------------------------------------------------------
unsigned long lastAutoArmCheck = 0;

void checkAutoArm() {
    if (millis() - lastAutoArmCheck > 10000) { // Check every 10s
        lastAutoArmCheck = millis();
        
        if (!Firebase.ready()) return;
        
        time_t now = time(nullptr);
        struct tm *timeinfo = localtime(&now);
        if (timeinfo->tm_year < 120) return; // NTP not ready
        
        // 1. Get Schedule from Firebase
        if (Firebase.RTDB.getBool(&fbdo, "/devices/" + savedDeviceId + "/settings/auto_arm/enabled")) {
             bool enabled = fbdo.boolData();
             if (enabled) {
                 if (Firebase.RTDB.getString(&fbdo, "/devices/" + savedDeviceId + "/settings/auto_arm/time")) {
                     String schedTime = fbdo.stringData();
                     
                     // Format Current Time HH:MM
                     char buffer[6];
                     strftime(buffer, 6, "%H:%M", timeinfo);
                     String currentTime = String(buffer);
                     
                     if (currentTime == schedTime) {
                         // TRIGGER ARM
                         // Check if already armed to prevent redundant ops
                          if (Firebase.RTDB.getString(&fbdo, "/devices/" + savedDeviceId + "/door_command")) {
                              if (fbdo.stringData() != "ARM") {
                                  Serial.println("‚è∞ Auto-Arm Triggered! Setting ARM...");
                                  Firebase.RTDB.setString(&fbdo, "/devices/" + savedDeviceId + "/door_command", "ARM");
                              }
                          }
                     }
                 }
             }
        }
    }
}

// -------------------------------------------------------------------
// MAIN
// -------------------------------------------------------------------
void setup() {
  Serial.begin(115200);
  pinMode(reedPin, INPUT_PULLUP);
  SPIFFS.begin(true);
  initTime();

  if (loadConfig()) {
    Serial.println("Config Loaded. Connecting...");
    if (connectToWiFi(savedSsid, savedPass)) {
      if (initFirebase(savedDeviceId, savedCustomToken)) {
        firebaseReady = true;
      }
    }
  }

  if (!firebaseReady) {
    Serial.println("Connection failed. Starting AP.");
    startAP();
  }
}

String lastState = "";
unsigned long lastTime = 0;
unsigned long lastHeartbeat = 0; 

void sendHeartbeat() {
  if (millis() - lastHeartbeat > 15000) { // Every 15 seconds
    lastHeartbeat = millis();
    if (!Firebase.ready()) return;

    time_t now = time(nullptr);
    if (now > 100000) { 
       Firebase.RTDB.setInt(&fbdo, "/devices/" + savedDeviceId + "/last_seen", (int)now);
       Serial.println("‚ù§Ô∏è Heartbeat Sent: " + String((int)now));
    }
  }
}

void loop() {
  if (!firebaseReady) {
    server.handleClient();
    delay(2);
    return;
  }

  // 1. Send Heartbeat
  sendHeartbeat();
  
  // 2. Check Auto-Arm Schedule
  checkAutoArm();

  // 3. Check Sensor 
  if (millis() - lastTime > 300) {
    lastTime = millis();
    String currentState = (digitalRead(reedPin) == LOW) ? "Closed" : "Open";

    // Check Command
    bool armed = false;
    if (Firebase.RTDB.getString(&fbdo, "/devices/" + savedDeviceId + "/door_command")) {
      String cmd = fbdo.stringData();
      if (cmd == "ARM") {
          armed = true;
      } else if (cmd == "RESET") {
          Serial.println("Received RESET command. Wiping config...");
          SPIFFS.remove(CONFIG_FILE);
          Firebase.RTDB.deleteNode(&fbdo, "/devices/" + savedDeviceId + "/door_command"); 
          delay(1000);
          ESP.restart();
      }
    }

    if (armed && currentState != lastState) {
      lastState = currentState;
      sendState(currentState);
    }
  }
}
